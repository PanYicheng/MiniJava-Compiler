package minijava.symboltable;import java.util.HashSet;import java.util.Hashtable;public class MClass extends MIdentifier//类标识符{	protected int nSize;//占内存	private int nMethodSize;//方法所占内存	private Hashtable<Integer, MMethod> methodOffsets = new Hashtable<Integer, MMethod>();//方法偏移表	private Hashtable<Integer, MVar> varOffsets = new Hashtable<Integer, MVar>();//变量偏移表		private String szBase;//基类	private Hashtable<String, MMethod> methodList = new Hashtable<String, MMethod>();//方法列表	private Hashtable<String, MVar> varList = new Hashtable<String, MVar>();//变量列表	public MClass(String szName)	{		super(szName, "class", null);//类型恒定为类    }		public void setBase(String szBase)//设置基类	{		this.szBase = szBase;	}		public String getBase()//获取基类	{		return szBase;	}		public boolean insertMethod(MMethod newMethod, int nLine)//插入方法	{		String szNewMethod = newMethod.getName();		if (methodList.containsKey(szNewMethod))//已经有了		{			szNewMethod += "repeated " + nLine;			methodList.put(szNewMethod, newMethod);//加上行号特征继续插入，以便对此方法进行类型检查			return false;		}				methodList.put(szNewMethod, newMethod);		return true;	}		public MMethod getMethod(String szName)	{		MMethod newMethod = methodList.get(szName);//获取方法		if (newMethod != null) return newMethod;		else return getMethodInBase(szName);//找不到就找基类	}		public MMethod getMethod(String szName, int nLine)//获取方法，仅在定义中用，便于类型检查	{		MMethod newMethod = methodList.get(szName + "repeated " + nLine);//按行号是否是重复的		if (newMethod != null) return newMethod;		else return methodList.get(szName);//不是直接查名字	}		public MMethod getMethodInBase(String szMethod)//在基类中找	{		HashSet<String> lstBase = new HashSet<String>();		lstBase.add(szName);				String szCurrentBase = szBase;		MClass currentClass = this;				while (szCurrentBase != null && !lstBase.contains(szCurrentBase))//有基类且非循环继承		{			lstBase.add(szCurrentBase);						currentClass = classList.get(szCurrentBase);			if (currentClass == null) return null;//基类不存在						MMethod baseMethod = currentClass.methodList.get(szMethod);			if (baseMethod != null) return baseMethod;//得到方法						szCurrentBase = currentClass.szBase;		}				return null;	}		public boolean insertVar(MVar newVar)//插入变量	{		String szNewVar = newVar.getName();		if (varList.containsKey(szNewVar)) return false;//必须非重复定义				varList.put(szNewVar, newVar);		return true;	}		public MVar getVar(String szName)//获取变量	{		MVar newVar = varList.get(szName);		if (newVar != null) return newVar;		else return getVarInBase(szName);//找不到则在基类找	}		public MVar getVarInBase(String szVar)//在基类找变量	{		HashSet<String> lstBase = new HashSet<String>();		lstBase.add(szName);				String szCurrentBase = szBase;		MClass currentClass = this;				while (szCurrentBase != null && !lstBase.contains(szCurrentBase))//有基类且非循环继承		{			lstBase.add(szCurrentBase);						currentClass = classList.get(szCurrentBase);			if (currentClass == null) return null;//基类不存在						MVar baseVar = currentClass.varList.get(szVar);			if (baseVar != null) return baseVar;//得到变量						szCurrentBase = currentClass.szBase;		}				return null;	}			public String toString()//打印出来	{		String szTemp = "class " + szName;		if (szBase != null) szTemp += " extends " + szBase;//类名和基类名				szTemp += "\n{\n";				for (MVar _var : varList.values()) szTemp += "\t" + _var + ";\n";//打印变量		if (varList.size() > 0 && methodList.size() > 0) szTemp += "\n";		for (MMethod _method : methodList.values()) szTemp += _method;//打印方法				szTemp += "}\n\n";				return szTemp;	}		public int alloc(int nTemp, HashSet<String> methodPigletNames)//分配偏移值，设置方法的PigletName	{				setOffsets(methodOffsets, varOffsets);				nSize = varOffsets.size() * 4 + 4;		nMethodSize = methodOffsets.size() * 4;				for (MMethod _method : methodList.values())//避免如A类下的B_C函数与A_B类下的C函数重名		{			nTemp = _method.alloc(nTemp, methodPigletNames);		}				return nTemp;	}		private void setOffsets(Hashtable<Integer, MMethod> methodOffsets, Hashtable<Integer, MVar> varOffsets)//设置偏移	{		if (szBase != null)		{			MClass baseClass = classList.get(szBase);			if (baseClass != null) baseClass.setOffsets(methodOffsets, varOffsets);//先在基类找		}				int nSize, nMethodSize, nBaseMethodSize;				nSize = varOffsets.size() * 4 + 4;		nMethodSize = nBaseMethodSize = methodOffsets.size() * 4;				for (MVar _var : varList.values())//加入各变量		{			_var.setOffset(nSize);			varOffsets.put(nSize, _var);			nSize += 4;		}				for (MMethod _method : methodList.values())//加入各方法		{			boolean bFlag = true;			for (int i = 0; i < nBaseMethodSize; i += 4)			{				if (methodOffsets.get(i).getName().equals(_method.getName()))				{					_method.setOffset(i);					methodOffsets.put(i, _method);//覆盖掉基类方法										bFlag = false;					break;				}			}						if (bFlag)//没有覆盖，加入新方法			{				_method.setOffset(nMethodSize);				methodOffsets.put(nMethodSize, _method);				nMethodSize += 4;			}		}	}		public int getSize() { return nSize; }	public int getMethodSize() { return nMethodSize; }		public MVar getVarByOffset(int nOffset)//根据偏移获取变量	{		return varOffsets.get(nOffset);	}		public MMethod getMethodByOffset(int nOffset)	{		return methodOffsets.get(nOffset);	}		public boolean isBasicType() { return false; }//是否基本类型}class MBasicType extends MClass//基本类型，专指int, boolean, int []{	public MBasicType(String szName)	{		super(szName);	}		@Override	public int alloc(int nTemp, HashSet<String> methodPigletNames)//分配偏移值	{				nSize = 4;		return nTemp;	}		public boolean isBasicType() { return true; }//是否基本类型}