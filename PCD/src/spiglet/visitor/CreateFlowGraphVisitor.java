//
// Generated by JTB 1.3.2
//

package spiglet.visitor;
import java.util.Enumeration;
import java.util.Vector;

import spiglet.symboltable.SMethod;
import spiglet.symboltable.SStatement;
import spiglet.syntaxtree.CJumpStmt;
import spiglet.syntaxtree.Call;
import spiglet.syntaxtree.ErrorStmt;
import spiglet.syntaxtree.Goal;
import spiglet.syntaxtree.IntegerLiteral;
import spiglet.syntaxtree.JumpStmt;
import spiglet.syntaxtree.Label;
import spiglet.syntaxtree.MoveStmt;
import spiglet.syntaxtree.Node;
import spiglet.syntaxtree.NodeListOptional;
import spiglet.syntaxtree.NodeOptional;
import spiglet.syntaxtree.NodeToken;
import spiglet.syntaxtree.Procedure;
import spiglet.syntaxtree.SimpleExp;
import spiglet.syntaxtree.Stmt;
import spiglet.syntaxtree.StmtExp;
import spiglet.syntaxtree.Temp;
import spiglet.syntaxtree.special.CallStmt;
import spiglet.syntaxtree.special.MoveArgStmt;
import spiglet.syntaxtree.special.MoveCallStmt;
import spiglet.syntaxtree.special.MoveTempStmt;
import spiglet.syntaxtree.special.PassArgStmt;
import spiglet.syntaxtree.special.Reg;
import spiglet.syntaxtree.special.ReturnStmt;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class CreateFlowGraphVisitor extends GJVoidDepthFirst<SMethod>//创建流图
{
	private Label lastLabel;//上一个写在Stmt前的Label;
	private int nLastArgs;//实参个数
	
	private Vector<SMethod> lstMethod = new Vector<SMethod>();//过程列表
	
	public Vector<SMethod> getMethods()
	{
		return lstMethod;//获取过程
	}
	//
	// Auto class visitors--probably don't need to be overridden.
	//
	
	public void visit(NodeListOptional n, SMethod argu)
	{
		if (n.present())
		{
			for (Enumeration<Node> e = n.elements(); e.hasMoreElements();)
			{
				Node node = e.nextElement();//获取下一个元素
				if (node instanceof Temp)//实参列表
				{
					if (nLastArgs < 4)//前四个直接移动
					{
						Node moveArgStmt = new MoveArgStmt(
								new Reg(18 + nLastArgs, new NodeToken("a" + nLastArgs)), (Temp) node); 
						SStatement stmt = new SStatement(moveArgStmt);
						argu.addStmt(stmt);
					}
					else//其他的压栈
					{
						Node passArgStmt = new PassArgStmt(new IntegerLiteral(
								new NodeToken(Integer.toString(nLastArgs - 3))), (Temp) node);
						
						SStatement stmt = new SStatement(passArgStmt);
						argu.addStmt(stmt);
					}
					++nLastArgs;
				}
				node.accept(this,argu);
			}
		}
	}

	public void visit(NodeOptional n, SMethod argu)
	{
		if (n.present())
		{
			n.node.accept(this,argu);
			if (n.node instanceof Label) lastLabel = (Label) n.node;
		}
	}
	
	//
	// User-generated visitor methods below
	//

	/**
	 * f0 -> "MAIN"
	 * f1 -> StmtList()
	 * f2 -> "END"
	 * f3 -> ( Procedure() )*
	 * f4 -> <EOF>
	 */
	public void visit(Goal n, SMethod argu)
	{
		SMethod method = new SMethod("MAIN", 0);//创建MAIN过程
		lstMethod.add(method);//加入过程
		
		n.f1.accept(this, method);//遍历其内容
		method.createFlowGraph();//建立流图
		
		n.f3.accept(this, null);//遍历其他过程
		
		int nLabelCount = 0;
		for (SMethod m : lstMethod) nLabelCount = m.reassignLabel(nLabelCount);//重新分配全局标签
		return;
	}
	
	/**
	 * f0 -> Label()
	 * f1 -> "["
	 * f2 -> IntegerLiteral()
	 * f3 -> "]"
	 * f4 -> StmtExp()
	 */
	public void visit(Procedure n, SMethod argu)
	{
		String szMethod = n.f0.f0.toString();//获取过程名
		
		String szArgs = n.f2.f0.toString();
		int nArgs = Integer.parseInt(szArgs);//获取参数个数
		
		SMethod method = new SMethod(szMethod, nArgs);//建立过程
		lstMethod.add(method);//加入过程
		
		n.f4.accept(this, method);//遍历过程内部
		method.createFlowGraph();//建立流图
	}

	/**
	 * f0 -> NoOpStmt()
	 *		 | ErrorStmt()
	 *		 | CJumpStmt()
	 *		 | JumpStmt()
	 *		 | HStoreStmt()
	 *		 | HLoadStmt()
	 *		 | MoveStmt()
	 *		 | PrintStmt()
	 */
	public void visit(Stmt n, SMethod argu)
	{
		if (lastLabel != null)
		{
			argu.newBlock();//如果有标签，建立新块
			argu.setEntryLabel(lastLabel.f0.tokenImage);//加入入口标签
			lastLabel = null;//标签设为空
		}
		
		
		if (!(n.f0.choice instanceof MoveStmt))//如果不是Move语句
		{
			SStatement stmt = new SStatement(n.f0.choice);//加入语句
			argu.addStmt(stmt);
		}
		n.f0.accept(this, argu);
	}
	
	/**
	 * f0 -> "ERROR"
	 */
	public void visit(ErrorStmt n, SMethod argu)//报错语句创建新块
	{ 
		argu.newBlock();
	}
	
	/**
	 * f0 -> "MOVE"
	 * f1 -> Temp()
	 * f2 -> Exp()
	 */
	public void visit(MoveStmt n, SMethod argu)
	{
		if (n.f2.f0.choice instanceof Call)
		{
			n.f2.accept(this, argu);
			SStatement stmt = new SStatement(new MoveCallStmt(n.f1));//分拆
			argu.addStmt(stmt);
		}
		else 
		{
			if (n.f2.f0.choice instanceof SimpleExp)
			{
				SimpleExp exp = (SimpleExp) n.f2.f0.choice;
				if (exp.f0.choice instanceof Temp)
				{
					SStatement stmt = new SStatement(new MoveTempStmt(n.f1, (Temp) exp.f0.choice));
					argu.addStmt(stmt);
				}
				else
				{
					SStatement stmt = new SStatement(n);//加入语句
					argu.addStmt(stmt);
				}
			}
			else
			{
				SStatement stmt = new SStatement(n);//加入语句
				argu.addStmt(stmt);
			}
		}
	}
	
	/**
	 * f0 -> "CJUMP"
	 * f1 -> Temp()
	 * f2 -> Label()
	 */
	public void visit(CJumpStmt n, SMethod argu)
	{ 
		argu.setExitLabel(n.f2.f0.tokenImage);
		argu.newBlock();//创建新块
	}

	/**
	 * f0 -> "JUMP"
	 * f1 -> Label()
	 */
	public void visit(JumpStmt n, SMethod argu)
	{  
		argu.setExitLabel(n.f1.f0.tokenImage);
		argu.newBlock();//创建新块
	}
	
	/**
	 * f0 -> "BEGIN"
	 * f1 -> StmtList()
	 * f2 -> "RETURN"
	 * f3 -> SimpleExp()
	 * f4 -> "END"
	 */
	public void visit(StmtExp n, SMethod argu)//过程语句表达式
	{ 
		n.f1.accept(this, argu);//遍历各语句		
		SStatement stmt = new SStatement(new ReturnStmt(n.f3));//加入语句
		argu.addStmt(stmt);
	}

	/**
	 * f0 -> "CALL"
	 * f1 -> SimpleExp()
	 * f2 -> "("
	 * f3 -> ( Temp() )*
	 * f4 -> ")"
	 */
	public void visit(Call n, SMethod argu)
	{ 
		nLastArgs = 0;//参数数
		n.f3.accept(this, argu);//遍历参数列表
		argu.setMaxCallArgs(nLastArgs);//更新参数数
		
		SStatement stmt = new SStatement(new CallStmt(n.f1));//加入语句
		argu.addStmt(stmt);
	}
}
